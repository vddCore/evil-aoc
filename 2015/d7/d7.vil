val Circuit = require("classes.Circuit");

val opcodes = {
  not: 0, and: 1, or: 2,
  lsh: 3, rsh: 4, set: 5
};

loc fn decode(line) {
  val in_out = str.spl(line, " -> ");
  val input = str.spl(in_out[0], " ");
  val r = { out: in_out[1] };

  rw val tok_0 = input[0];

  if (#input == 1) {
    r.op = opcodes.set;
    r.in_1 = $tok_0 ?? tok_0;
  } else {
    tok_0 = input[0];

    if (tok_0 == "NOT") {
      r.op = opcodes.not;
      r.in_1 = $input[1] ?? input[1];
    } else {
      r.in_1 = $tok_0 ?? tok_0;
      r.in_2 = $input[2] ?? input[2];

      val op = input[1];
      if (op == "AND") {
        r.op = opcodes.and;
      } elif (op == "OR") {
        r.op = opcodes.or;
      } elif (op == "LSHIFT") {
        r.op = opcodes.lsh;
      } elif (op == "RSHIFT") {
        r.op = opcodes.rsh;
      }
    }
  }

  ret r;
}

val data = fs.file.get_lines("d7.dat");
val circuit = Circuit::new();

each (rw val _, line : data) {
  val insn = decode(line);

  if (insn.op == opcodes.not) { circuit::set_not(insn.out, insn.in_1); } 
  elif (insn.op == opcodes.and) { circuit::set_and(insn.out, insn.in_1, insn.in_2); } 
  elif (insn.op == opcodes.or) { circuit::set_or(insn.out, insn.in_1, insn.in_2); } 
  elif (insn.op == opcodes.lsh) { circuit::set_lsh(insn.out, insn.in_1, insn.in_2); } 
  elif (insn.op == opcodes.rsh) { circuit::set_rsh(insn.out, insn.in_1, insn.in_2); } 
  elif (insn.op == opcodes.set) { circuit::set_hardwired(insn.out, insn.in_1); }
}

rw val wire_a = circuit::get_signal_value("a");
io.println("wire a before change: " + @wire_a);

circuit::reset();
circuit::set_hardwired("b", wire_a);

wire_a = circuit::get_signal_value("a");
io.println("wire a after change: " + @wire_a);